{"ast":null,"code":"// src/utils/blockchain.ts\n\nimport { ethers, parseEther } from 'ethers';\nimport { toast } from 'react-hot-toast'; // Import toast for user feedback\n\n// Import global types\n\n// --- Configuration ---\n// Read from environment variables or use defaults\nconst CONTRACT_ADDRESS = process.env.REACT_APP_CONTRACT_ADDRESS || 'YOUR_DEPLOYED_EVENT_MANAGER_ADDRESS';\nconst TARGET_NETWORK_ID = parseInt(process.env.REACT_APP_TARGET_NETWORK_ID || '0', 10);\nconst TARGET_NETWORK_NAME = process.env.REACT_APP_TARGET_NETWORK_NAME || 'Required Network';\n\n// --- ABIs ---\n// IMPORTANT: Replace with your ACTUAL compiled ABIs!\n\nconst EVENT_MANAGER_ABI = [\n// --- Paste your full EventManager ABI array here ---\n// Example functions needed: ticketNFT(), ticketPriceInsider(), ticketPriceOutsider(),\n// maxTickets(), ticketCount(), buyTicket(), sellTicketBack(), refunded(), issuedTickets(uint256) ...\n{\n  \"inputs\": [],\n  \"name\": \"ticketNFT\",\n  \"outputs\": [{\n    \"internalType\": \"contract TicketNFT\",\n    \"name\": \"\",\n    \"type\": \"address\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [],\n  \"name\": \"ticketPriceInsider\",\n  \"outputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [],\n  \"name\": \"ticketPriceOutsider\",\n  \"outputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [],\n  \"name\": \"maxTickets\",\n  \"outputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [],\n  \"name\": \"ticketCount\",\n  \"outputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"string\",\n    \"name\": \"tokenURI\",\n    \"type\": \"string\"\n  }, {\n    \"internalType\": \"string\",\n    \"name\": \"qrHash\",\n    \"type\": \"string\"\n  }, {\n    \"internalType\": \"bool\",\n    \"name\": \"outsider\",\n    \"type\": \"bool\"\n  }],\n  \"name\": \"buyTicket\",\n  \"outputs\": [],\n  \"stateMutability\": \"payable\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"tokenId\",\n    \"type\": \"uint256\"\n  }],\n  \"name\": \"sellTicketBack\",\n  \"outputs\": [],\n  \"stateMutability\": \"nonpayable\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"name\": \"refunded\",\n  \"outputs\": [{\n    \"internalType\": \"bool\",\n    \"name\": \"\",\n    \"type\": \"bool\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"index\",\n    \"type\": \"uint256\"\n  }],\n  \"name\": \"issuedTickets\",\n  \"outputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n} // Ensure index is param name if needed\n// ... Add ALL OTHER EventManager functions/events/errors from your compiled ABI\n];\nconst TICKET_NFT_ABI = [\n// --- Minimal TicketNFT ABI needed by these utils ---\n{\n  \"inputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"tokenId\",\n    \"type\": \"uint256\"\n  }],\n  \"name\": \"tokenURI\",\n  \"outputs\": [{\n    \"internalType\": \"string\",\n    \"name\": \"\",\n    \"type\": \"string\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"address\",\n    \"name\": \"owner\",\n    \"type\": \"address\"\n  }],\n  \"name\": \"balanceOf\",\n  \"outputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"address\",\n    \"name\": \"owner\",\n    \"type\": \"address\"\n  }, {\n    \"internalType\": \"uint256\",\n    \"name\": \"index\",\n    \"type\": \"uint256\"\n  }],\n  \"name\": \"tokenOfOwnerByIndex\",\n  \"outputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"\",\n    \"type\": \"uint256\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"tokenId\",\n    \"type\": \"uint256\"\n  }],\n  \"name\": \"ownerOf\",\n  \"outputs\": [{\n    \"internalType\": \"address\",\n    \"name\": \"\",\n    \"type\": \"address\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n}, {\n  \"inputs\": [{\n    \"internalType\": \"uint256\",\n    \"name\": \"tokenId\",\n    \"type\": \"uint256\"\n  }],\n  \"name\": \"getQRHash\",\n  \"outputs\": [{\n    \"internalType\": \"string\",\n    \"name\": \"\",\n    \"type\": \"string\"\n  }],\n  \"stateMutability\": \"view\",\n  \"type\": \"function\"\n} // Assuming getQRHash is on TicketNFT\n// ... Add other TicketNFT functions if needed\n];\n// ----------------------------\n\n// Basic validation for config\nif (!CONTRACT_ADDRESS || CONTRACT_ADDRESS === 'YOUR_DEPLOYED_EVENT_MANAGER_ADDRESS') console.error(\"REACT_APP_CONTRACT_ADDRESS not set.\");\nif (!TARGET_NETWORK_ID) console.error(\"REACT_APP_TARGET_NETWORK_ID not set.\");\nif (EVENT_MANAGER_ABI.length === 0) console.error(\"EVENT_MANAGER_ABI is empty.\");\nif (TICKET_NFT_ABI.length < 3) console.error(\"TICKET_NFT_ABI is missing required functions (tokenURI, balanceOf, tokenOfOwnerByIndex, ownerOf).\");\n\n// --- Type Definitions ---\n\n// --- Helper Functions ---\nconst getProvider = () => {\n  if (typeof window.ethereum === 'undefined') {\n    console.warn('MetaMask not detected.');\n    return null;\n  }\n  try {\n    // Ethers v6 uses BrowserProvider\n    return new ethers.BrowserProvider(window.ethereum);\n  } catch (e) {\n    console.error(\"Error creating provider:\", e);\n    return null;\n  }\n};\nconst getSigner = async provider => {\n  try {\n    // Request accounts first is good practice\n    await provider.send('eth_requestAccounts', []);\n    return await provider.getSigner();\n  } catch (e) {\n    console.error(\"Error getting signer:\", e);\n    toast.error(\"Could not connect to wallet. Did you approve the connection?\");\n    return null;\n  }\n};\n\n// Gets EventManager contract instance\nconst getEventManagerContract = async (readOnly = false) => {\n  const provider = getProvider();\n  if (!provider) return null;\n  // Ensure ABI has length before creating contract\n  if (!EVENT_MANAGER_ABI || EVENT_MANAGER_ABI.length === 0) {\n    console.error(\"EventManager ABI is missing or empty.\");\n    return null;\n  }\n  try {\n    if (readOnly) {\n      return new ethers.Contract(CONTRACT_ADDRESS, EVENT_MANAGER_ABI, provider);\n    } else {\n      const signer = await getSigner(provider);\n      if (!signer) return null; // Signer is required for transactions\n      return new ethers.Contract(CONTRACT_ADDRESS, EVENT_MANAGER_ABI, signer);\n    }\n  } catch (error) {\n    console.error(\"Error creating EventManager contract instance:\", error);\n    return null;\n  }\n};\n\n// Gets TicketNFT contract instance (requires fetching address first)\nconst getTicketNFTContract = async (readOnly = false) => {\n  const eventManagerContract = await getEventManagerContract(true); // Read-only is fine\n  if (!eventManagerContract) return null;\n  try {\n    const nftContractAddress = await eventManagerContract.ticketNFT();\n    if (!nftContractAddress || nftContractAddress === ethers.ZeroAddress) {\n      console.error(\"TicketNFT address not set or invalid in EventManager.\");\n      return null;\n    }\n    // Ensure NFT ABI has length\n    if (!TICKET_NFT_ABI || TICKET_NFT_ABI.length === 0) {\n      console.error(\"TicketNFT ABI is missing or empty.\");\n      return null;\n    }\n    const provider = getProvider();\n    if (!provider) return null;\n    if (readOnly) {\n      return new ethers.Contract(nftContractAddress, TICKET_NFT_ABI, provider);\n    } else {\n      const signer = await getSigner(provider);\n      if (!signer) return null;\n      return new ethers.Contract(nftContractAddress, TICKET_NFT_ABI, signer);\n    }\n  } catch (error) {\n    console.error(\"Error creating TicketNFT contract instance:\", error);\n    return null;\n  }\n};\n\n// --- Core Blockchain Functions ---\n\nexport const connectWallet = async () => {/* ... as before ... */};\nexport const checkNetwork = async () => {/* ... as before ... */};\n\n// Corrected switchNetwork (no argument)\nexport const switchNetwork = async () => {\n  const provider = getProvider();\n  if (!provider || !window.ethereum) {\n    toast.error(\"MetaMask is not available to switch network.\");\n    return false;\n  }\n  try {\n    await window.ethereum.request({\n      method: 'wallet_switchEthereumChain',\n      params: [{\n        chainId: ethers.toQuantity(TARGET_NETWORK_ID)\n      }] // Use constant/env var\n    });\n    return true;\n  } catch (switchError) {\n    console.error('Network switch failed:', switchError);\n    if (switchError.code === 4902) {\n      toast.error(`Network \"${TARGET_NETWORK_NAME}\" not added to MetaMask.`);\n      // Optionally add logic here to call wallet_addEthereumChain\n    } else if (switchError.code === 4001) {\n      toast.info('Network switch rejected.');\n    } else {\n      toast.error('Failed to switch network.');\n    }\n    return false;\n  }\n};\n\n// Corrected buyTicket\nexport const buyTicket = async (tokenURI, qrHash, outsider, priceInEther) => {\n  const contract = await getEventManagerContract(false); // EventManager handles buying\n  if (!contract) throw new Error(\"EventManager Contract not available.\");\n  if (!priceInEther) throw new Error(\"Price is required to buy ticket.\");\n  try {\n    var _receipt$transactionH;\n    const value = parseEther(priceInEther);\n    console.log(`Calling contract.buyTicket(\"${tokenURI}\", \"${qrHash}\", ${outsider}, { value: ${value.toString()} })`);\n    const tx = await contract.buyTicket(tokenURI, qrHash, outsider, {\n      value\n    });\n    const receipt = await tx.wait();\n    console.log(`Transaction Confirmed: ${receipt === null || receipt === void 0 ? void 0 : receipt.transactionHash}`);\n    return (_receipt$transactionH = receipt === null || receipt === void 0 ? void 0 : receipt.transactionHash) !== null && _receipt$transactionH !== void 0 ? _receipt$transactionH : null;\n  } catch (error) {\n    var _error$data;\n    console.error(\"Buy Ticket Error:\", error);\n    const reason = error.reason || (error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.message) || error.message || 'Unknown error';\n    if (error.code === 4001) throw new Error('Transaction rejected.');\n    // Attempt to provide a more specific revert reason\n    throw new Error(`Purchase Failed: ${reason}`);\n  }\n};\n\n// --- Corrected getMyTickets ---\nexport const getMyTickets = async userAddress => {\n  if (!userAddress) return [];\n  const nftContract = await getTicketNFTContract(true); // Get read-only NFT contract\n  if (!nftContract) {\n    console.error(\"getMyTickets: Could not get TicketNFT contract instance.\");\n    throw new Error(\"Failed to connect to NFT contract.\"); // Throw error to be caught\n  }\n  try {\n    // Ensure ABI used for nftContract includes balanceOf and tokenOfOwnerByIndex\n    const balanceBN = await nftContract.balanceOf(userAddress);\n    const balance = Number(balanceBN); // Convert BigInt balance to number\n    console.log(`User ${userAddress} has ${balance} tickets.`);\n    if (balance === 0) return [];\n    const ownedTickets = [];\n    // Create promises array for concurrent fetching\n    const promises = [];\n    for (let i = 0; i < balance; i++) {\n      promises.push(nftContract.tokenOfOwnerByIndex(userAddress, i));\n    }\n    // Resolve all promises\n    const results = await Promise.all(promises);\n    results.forEach(tokenIdBN => {\n      ownedTickets.push(Number(tokenIdBN)); // Convert BigInt token ID to number\n    });\n    console.log(\"Owned ticket IDs:\", ownedTickets);\n    return ownedTickets;\n  } catch (error) {\n    var _error$message;\n    console.error(\"Error in getMyTickets:\", error);\n    // Check if the error suggests the contract doesn't support enumeration\n    if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes(\"contract runner does not support\")) {\n      throw new Error(\"Failed to fetch owned tickets. The NFT contract might not support enumeration (ERC721Enumerable).\");\n    }\n    throw new Error(\"Failed to fetch owned tickets.\"); // Re-throw generic error\n  }\n};\n\n// Corrected resellTicket (uses EventManager)\nexport const resellTicket = async tokenId => {\n  const contract = await getEventManagerContract(false); // EventManager handles resale\n  if (!contract) throw new Error(\"EventManager Contract not available.\");\n  try {\n    var _receipt$transactionH2;\n    console.log(`Calling contract.sellTicketBack(${tokenId})`);\n    const tx = await contract.sellTicketBack(tokenId);\n    const receipt = await tx.wait();\n    console.log(`Resale Confirmed: ${receipt === null || receipt === void 0 ? void 0 : receipt.transactionHash}`);\n    return (_receipt$transactionH2 = receipt === null || receipt === void 0 ? void 0 : receipt.transactionHash) !== null && _receipt$transactionH2 !== void 0 ? _receipt$transactionH2 : null;\n  } catch (error) {\n    var _error$data2;\n    console.error(`Resell Ticket Error (ID: ${tokenId}):`, error);\n    const reason = error.reason || (error === null || error === void 0 ? void 0 : (_error$data2 = error.data) === null || _error$data2 === void 0 ? void 0 : _error$data2.message) || error.message || 'Unknown error';\n    if (error.code === 4001) throw new Error('Transaction rejected.');\n    throw new Error(`Resale Failed: ${reason}`);\n  }\n};\n\n// Corrected getEventDetails\nexport const getEventDetails = async () => {\n  const contract = await getEventManagerContract(true);\n  if (!contract) return null;\n  try {\n    const details = {\n      // Ensure these function names match your EventManager ABI\n      ticketPriceInsider: await contract.ticketPriceInsider(),\n      ticketPriceOutsider: await contract.ticketPriceOutsider(),\n      totalTickets: await contract.maxTickets(),\n      soldTickets: await contract.ticketCount()\n      // Fetch other details if needed\n    };\n    return details;\n  } catch (error) {\n    console.error(\"Failed to fetch event details:\", error);\n    return null;\n  }\n};\n\n// Corrected getTokenMetadataURI\nexport const getTokenMetadataURI = async tokenId => {\n  const nftContract = await getTicketNFTContract(true); // Helper gets the NFT contract\n  if (!nftContract) return null;\n  try {\n    // Ensure TICKET_NFT_ABI includes tokenURI\n    const uri = await nftContract.tokenURI(tokenId);\n    return uri;\n  } catch (error) {\n    // Handle cases where token might not exist or URI is not set\n    console.error(`Error getting token URI for token ${tokenId}:`, error.message);\n    return null;\n  }\n};\n\n// --- Updated getAvailableTickets ---\n// This implementation fetches all minted ticket IDs and leaves filtering to the frontend.\n// A more robust solution might involve contract changes or complex event filtering.\nexport const getAvailableTickets = async () => {\n  const contract = await getEventManagerContract(true);\n  if (!contract) return [];\n  try {\n    const countBN = await contract.ticketCount();\n    const count = Number(countBN);\n    if (count === 0) return [];\n    console.log(`Workspaceing ${count} issued ticket IDs...`);\n    const ids = [];\n    const promises = [];\n    // Loop through indices of the issuedTickets array/getter\n    for (let i = 0; i < count; i++) {\n      // Assuming issuedTickets getter takes an index\n      promises.push(contract.issuedTickets(i));\n    }\n    const results = await Promise.all(promises);\n    results.forEach(tokenIdBN => {\n      ids.push(Number(tokenIdBN));\n    });\n    console.log(\"All issued ticket IDs:\", ids);\n    // Frontend will need to filter these based on ownership/refunded status if needed\n    return ids;\n  } catch (error) {\n    console.error(\"Error getting available/issued tickets:\", error);\n    toast.error(\"Could not retrieve list of issued tickets.\");\n    return [];\n  }\n};\n\n// --- getQRHash (Example - Requires adding to TicketNFT ABI) ---\nexport const getQRHash = async tokenId => {\n  const nftContract = await getTicketNFTContract(true);\n  if (!nftContract) return null;\n  try {\n    // --- Ensure getQRHash exists in TICKET_NFT_ABI ---\n    const qrHash = await nftContract.getQRHash(tokenId);\n    return qrHash;\n  } catch (error) {\n    console.error(`Error getting QR Hash for token ${tokenId}:`, error);\n    return null;\n  }\n};","map":{"version":3,"names":["ethers","parseEther","toast","CONTRACT_ADDRESS","process","env","REACT_APP_CONTRACT_ADDRESS","TARGET_NETWORK_ID","parseInt","REACT_APP_TARGET_NETWORK_ID","TARGET_NETWORK_NAME","REACT_APP_TARGET_NETWORK_NAME","EVENT_MANAGER_ABI","TICKET_NFT_ABI","console","error","length","getProvider","window","ethereum","warn","BrowserProvider","e","getSigner","provider","send","getEventManagerContract","readOnly","Contract","signer","getTicketNFTContract","eventManagerContract","nftContractAddress","ticketNFT","ZeroAddress","connectWallet","checkNetwork","switchNetwork","request","method","params","chainId","toQuantity","switchError","code","info","buyTicket","tokenURI","qrHash","outsider","priceInEther","contract","Error","_receipt$transactionH","value","log","toString","tx","receipt","wait","transactionHash","_error$data","reason","data","message","getMyTickets","userAddress","nftContract","balanceBN","balanceOf","balance","Number","ownedTickets","promises","i","push","tokenOfOwnerByIndex","results","Promise","all","forEach","tokenIdBN","_error$message","includes","resellTicket","tokenId","_receipt$transactionH2","sellTicketBack","_error$data2","getEventDetails","details","ticketPriceInsider","ticketPriceOutsider","totalTickets","maxTickets","soldTickets","ticketCount","getTokenMetadataURI","uri","getAvailableTickets","countBN","count","ids","issuedTickets","getQRHash"],"sources":["C:/Users/negis/OneDrive/Desktop/new project/blockfest-ui/src/utils/blockchain.ts"],"sourcesContent":["// src/utils/blockchain.ts\r\n\r\nimport { ethers, parseEther, formatEther } from 'ethers';\r\nimport { toast } from 'react-hot-toast'; // Import toast for user feedback\r\nimport { TicketData, EventDetails } from '../types/global'; // Import global types\r\n\r\n// --- Configuration ---\r\n// Read from environment variables or use defaults\r\nconst CONTRACT_ADDRESS = process.env.REACT_APP_CONTRACT_ADDRESS || 'YOUR_DEPLOYED_EVENT_MANAGER_ADDRESS';\r\nconst TARGET_NETWORK_ID = parseInt(process.env.REACT_APP_TARGET_NETWORK_ID || '0', 10);\r\nconst TARGET_NETWORK_NAME = process.env.REACT_APP_TARGET_NETWORK_NAME || 'Required Network';\r\n\r\n// --- ABIs ---\r\n// IMPORTANT: Replace with your ACTUAL compiled ABIs!\r\n\r\nconst EVENT_MANAGER_ABI = [\r\n    // --- Paste your full EventManager ABI array here ---\r\n    // Example functions needed: ticketNFT(), ticketPriceInsider(), ticketPriceOutsider(),\r\n    // maxTickets(), ticketCount(), buyTicket(), sellTicketBack(), refunded(), issuedTickets(uint256) ...\r\n    {\"inputs\":[],\"name\":\"ticketNFT\",\"outputs\":[{\"internalType\":\"contract TicketNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},\r\n    {\"inputs\":[],\"name\":\"ticketPriceInsider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},\r\n    {\"inputs\":[],\"name\":\"ticketPriceOutsider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},\r\n    {\"inputs\":[],\"name\":\"maxTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},\r\n    {\"inputs\":[],\"name\":\"ticketCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},\r\n    {\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"qrHash\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"outsider\",\"type\":\"bool\"}],\"name\":\"buyTicket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},\r\n    {\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"sellTicketBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},\r\n    {\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},\r\n    {\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"issuedTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"} // Ensure index is param name if needed\r\n    // ... Add ALL OTHER EventManager functions/events/errors from your compiled ABI\r\n];\r\n\r\nconst TICKET_NFT_ABI = [\r\n    // --- Minimal TicketNFT ABI needed by these utils ---\r\n    {\"inputs\": [{\"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\"}],\"name\": \"tokenURI\",\"outputs\": [{\"internalType\": \"string\", \"name\": \"\", \"type\": \"string\"}],\"stateMutability\": \"view\",\"type\": \"function\"},\r\n    {\"inputs\": [{\"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\"}],\"name\": \"balanceOf\",\"outputs\": [{\"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"}],\"stateMutability\": \"view\",\"type\": \"function\"},\r\n    {\"inputs\": [{\"internalType\": \"address\", \"name\": \"owner\", \"type\": \"address\"}, {\"internalType\": \"uint256\", \"name\": \"index\", \"type\": \"uint256\"}],\"name\": \"tokenOfOwnerByIndex\",\"outputs\": [{\"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"}],\"stateMutability\": \"view\",\"type\": \"function\"},\r\n    {\"inputs\": [{\"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\"}],\"name\": \"ownerOf\",\"outputs\": [{\"internalType\": \"address\", \"name\": \"\", \"type\": \"address\"}],\"stateMutability\": \"view\",\"type\": \"function\"},\r\n    {\"inputs\": [{\"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\"}],\"name\": \"getQRHash\",\"outputs\": [{\"internalType\": \"string\", \"name\": \"\", \"type\": \"string\"}],\"stateMutability\": \"view\",\"type\": \"function\"} // Assuming getQRHash is on TicketNFT\r\n    // ... Add other TicketNFT functions if needed\r\n];\r\n// ----------------------------\r\n\r\n// Basic validation for config\r\nif (!CONTRACT_ADDRESS || CONTRACT_ADDRESS === 'YOUR_DEPLOYED_EVENT_MANAGER_ADDRESS') console.error(\"REACT_APP_CONTRACT_ADDRESS not set.\");\r\nif (!TARGET_NETWORK_ID) console.error(\"REACT_APP_TARGET_NETWORK_ID not set.\");\r\nif (EVENT_MANAGER_ABI.length === 0) console.error(\"EVENT_MANAGER_ABI is empty.\");\r\nif (TICKET_NFT_ABI.length < 3) console.error(\"TICKET_NFT_ABI is missing required functions (tokenURI, balanceOf, tokenOfOwnerByIndex, ownerOf).\");\r\n\r\n\r\n// --- Type Definitions ---\r\ninterface NetworkInfo { chainId: number; name: string; }\r\n\r\n// --- Helper Functions ---\r\nconst getProvider = (): ethers.BrowserProvider | null => {\r\n    if (typeof window.ethereum === 'undefined') {\r\n        console.warn('MetaMask not detected.');\r\n        return null;\r\n    }\r\n    try {\r\n        // Ethers v6 uses BrowserProvider\r\n        return new ethers.BrowserProvider(window.ethereum as any);\r\n    } catch (e) {\r\n        console.error(\"Error creating provider:\", e);\r\n        return null;\r\n    }\r\n};\r\n\r\nconst getSigner = async (provider: ethers.BrowserProvider): Promise<ethers.Signer | null> => {\r\n    try {\r\n        // Request accounts first is good practice\r\n        await provider.send('eth_requestAccounts', []);\r\n        return await provider.getSigner();\r\n    } catch (e) {\r\n        console.error(\"Error getting signer:\", e);\r\n        toast.error(\"Could not connect to wallet. Did you approve the connection?\");\r\n        return null;\r\n    }\r\n};\r\n\r\n// Gets EventManager contract instance\r\nconst getEventManagerContract = async (readOnly = false): Promise<ethers.Contract | null> => {\r\n    const provider = getProvider();\r\n    if (!provider) return null;\r\n    // Ensure ABI has length before creating contract\r\n    if (!EVENT_MANAGER_ABI || EVENT_MANAGER_ABI.length === 0) {\r\n        console.error(\"EventManager ABI is missing or empty.\");\r\n        return null;\r\n    }\r\n    try {\r\n        if (readOnly) {\r\n            return new ethers.Contract(CONTRACT_ADDRESS, EVENT_MANAGER_ABI, provider);\r\n        } else {\r\n            const signer = await getSigner(provider);\r\n            if (!signer) return null; // Signer is required for transactions\r\n            return new ethers.Contract(CONTRACT_ADDRESS, EVENT_MANAGER_ABI, signer);\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error creating EventManager contract instance:\", error);\r\n        return null;\r\n    }\r\n};\r\n\r\n// Gets TicketNFT contract instance (requires fetching address first)\r\nconst getTicketNFTContract = async (readOnly = false): Promise<ethers.Contract | null> => {\r\n    const eventManagerContract = await getEventManagerContract(true); // Read-only is fine\r\n    if (!eventManagerContract) return null;\r\n    try {\r\n        const nftContractAddress = await eventManagerContract.ticketNFT();\r\n        if (!nftContractAddress || nftContractAddress === ethers.ZeroAddress) {\r\n            console.error(\"TicketNFT address not set or invalid in EventManager.\");\r\n            return null;\r\n        }\r\n        // Ensure NFT ABI has length\r\n        if (!TICKET_NFT_ABI || TICKET_NFT_ABI.length === 0) {\r\n            console.error(\"TicketNFT ABI is missing or empty.\");\r\n            return null;\r\n        }\r\n        const provider = getProvider();\r\n        if (!provider) return null;\r\n\r\n        if (readOnly) {\r\n            return new ethers.Contract(nftContractAddress, TICKET_NFT_ABI, provider);\r\n        } else {\r\n            const signer = await getSigner(provider);\r\n            if (!signer) return null;\r\n            return new ethers.Contract(nftContractAddress, TICKET_NFT_ABI, signer);\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error creating TicketNFT contract instance:\", error);\r\n        return null;\r\n    }\r\n};\r\n\r\n\r\n// --- Core Blockchain Functions ---\r\n\r\nexport const connectWallet = async (): Promise<string | null> => { /* ... as before ... */ };\r\nexport const checkNetwork = async (): Promise<{ isCorrect: boolean; currentNetwork: NetworkInfo | null }> => { /* ... as before ... */ };\r\n\r\n// Corrected switchNetwork (no argument)\r\nexport const switchNetwork = async (): Promise<boolean> => {\r\n    const provider = getProvider();\r\n    if (!provider || !window.ethereum) {\r\n        toast.error(\"MetaMask is not available to switch network.\");\r\n        return false;\r\n    }\r\n    try {\r\n        await window.ethereum.request({\r\n            method: 'wallet_switchEthereumChain',\r\n            params: [{ chainId: ethers.toQuantity(TARGET_NETWORK_ID) }], // Use constant/env var\r\n        });\r\n        return true;\r\n    } catch (switchError: any) {\r\n        console.error('Network switch failed:', switchError);\r\n        if (switchError.code === 4902) {\r\n             toast.error(`Network \"${TARGET_NETWORK_NAME}\" not added to MetaMask.`);\r\n             // Optionally add logic here to call wallet_addEthereumChain\r\n        } else if (switchError.code === 4001) {\r\n             toast.info('Network switch rejected.');\r\n        } else {\r\n             toast.error('Failed to switch network.');\r\n        }\r\n        return false;\r\n    }\r\n};\r\n\r\n// Corrected buyTicket\r\nexport const buyTicket = async (\r\n    tokenURI: string,\r\n    qrHash: string,\r\n    outsider: boolean,\r\n    priceInEther: string // Expect price string here\r\n): Promise<string | null> => {\r\n    const contract = await getEventManagerContract(false); // EventManager handles buying\r\n    if (!contract) throw new Error(\"EventManager Contract not available.\");\r\n    if (!priceInEther) throw new Error(\"Price is required to buy ticket.\");\r\n\r\n    try {\r\n        const value = parseEther(priceInEther);\r\n        console.log(`Calling contract.buyTicket(\"${tokenURI}\", \"${qrHash}\", ${outsider}, { value: ${value.toString()} })`);\r\n        const tx = await contract.buyTicket(tokenURI, qrHash, outsider, { value });\r\n        const receipt = await tx.wait();\r\n        console.log(`Transaction Confirmed: ${receipt?.transactionHash}`);\r\n        return receipt?.transactionHash ?? null;\r\n    } catch (error: any) {\r\n        console.error(\"Buy Ticket Error:\", error);\r\n        const reason = error.reason || error?.data?.message || error.message || 'Unknown error';\r\n        if (error.code === 4001) throw new Error('Transaction rejected.');\r\n        // Attempt to provide a more specific revert reason\r\n        throw new Error(`Purchase Failed: ${reason}`);\r\n    }\r\n};\r\n\r\n// --- Corrected getMyTickets ---\r\nexport const getMyTickets = async (userAddress: string): Promise<number[]> => {\r\n    if (!userAddress) return [];\r\n    const nftContract = await getTicketNFTContract(true); // Get read-only NFT contract\r\n    if (!nftContract) {\r\n        console.error(\"getMyTickets: Could not get TicketNFT contract instance.\");\r\n        throw new Error(\"Failed to connect to NFT contract.\"); // Throw error to be caught\r\n    }\r\n    try {\r\n        // Ensure ABI used for nftContract includes balanceOf and tokenOfOwnerByIndex\r\n        const balanceBN = await nftContract.balanceOf(userAddress);\r\n        const balance = Number(balanceBN); // Convert BigInt balance to number\r\n        console.log(`User ${userAddress} has ${balance} tickets.`);\r\n        if (balance === 0) return [];\r\n\r\n        const ownedTickets: number[] = [];\r\n        // Create promises array for concurrent fetching\r\n        const promises: Promise<ethers.BigNumber>[] = [];\r\n        for (let i = 0; i < balance; i++) {\r\n            promises.push(nftContract.tokenOfOwnerByIndex(userAddress, i));\r\n        }\r\n        // Resolve all promises\r\n        const results = await Promise.all(promises);\r\n        results.forEach(tokenIdBN => {\r\n            ownedTickets.push(Number(tokenIdBN)); // Convert BigInt token ID to number\r\n        });\r\n\r\n        console.log(\"Owned ticket IDs:\", ownedTickets);\r\n        return ownedTickets;\r\n    } catch (error: any) {\r\n        console.error(\"Error in getMyTickets:\", error);\r\n        // Check if the error suggests the contract doesn't support enumeration\r\n        if (error.message?.includes(\"contract runner does not support\")) {\r\n             throw new Error(\"Failed to fetch owned tickets. The NFT contract might not support enumeration (ERC721Enumerable).\");\r\n        }\r\n        throw new Error(\"Failed to fetch owned tickets.\"); // Re-throw generic error\r\n    }\r\n};\r\n\r\n// Corrected resellTicket (uses EventManager)\r\nexport const resellTicket = async (tokenId: number): Promise<string | null> => {\r\n    const contract = await getEventManagerContract(false); // EventManager handles resale\r\n    if (!contract) throw new Error(\"EventManager Contract not available.\");\r\n    try {\r\n        console.log(`Calling contract.sellTicketBack(${tokenId})`);\r\n        const tx = await contract.sellTicketBack(tokenId);\r\n        const receipt = await tx.wait();\r\n        console.log(`Resale Confirmed: ${receipt?.transactionHash}`);\r\n        return receipt?.transactionHash ?? null;\r\n    } catch (error: any) {\r\n        console.error(`Resell Ticket Error (ID: ${tokenId}):`, error);\r\n        const reason = error.reason || error?.data?.message || error.message || 'Unknown error';\r\n        if (error.code === 4001) throw new Error('Transaction rejected.');\r\n        throw new Error(`Resale Failed: ${reason}`);\r\n    }\r\n};\r\n\r\n// Corrected getEventDetails\r\nexport const getEventDetails = async (): Promise<EventDetails | null> => {\r\n    const contract = await getEventManagerContract(true);\r\n    if (!contract) return null;\r\n    try {\r\n        const details: EventDetails = {\r\n            // Ensure these function names match your EventManager ABI\r\n            ticketPriceInsider: await contract.ticketPriceInsider(),\r\n            ticketPriceOutsider: await contract.ticketPriceOutsider(),\r\n            totalTickets: await contract.maxTickets(),\r\n            soldTickets: await contract.ticketCount(),\r\n            // Fetch other details if needed\r\n        };\r\n        return details;\r\n    } catch (error) {\r\n        console.error(\"Failed to fetch event details:\", error);\r\n        return null;\r\n    }\r\n};\r\n\r\n// Corrected getTokenMetadataURI\r\nexport const getTokenMetadataURI = async (tokenId: number): Promise<string | null> => {\r\n    const nftContract = await getTicketNFTContract(true); // Helper gets the NFT contract\r\n    if (!nftContract) return null;\r\n    try {\r\n        // Ensure TICKET_NFT_ABI includes tokenURI\r\n        const uri = await nftContract.tokenURI(tokenId);\r\n        return uri;\r\n    } catch (error: any) {\r\n        // Handle cases where token might not exist or URI is not set\r\n        console.error(`Error getting token URI for token ${tokenId}:`, error.message);\r\n        return null;\r\n    }\r\n};\r\n\r\n// --- Updated getAvailableTickets ---\r\n// This implementation fetches all minted ticket IDs and leaves filtering to the frontend.\r\n// A more robust solution might involve contract changes or complex event filtering.\r\nexport const getAvailableTickets = async (): Promise<number[]> => {\r\n    const contract = await getEventManagerContract(true);\r\n    if (!contract) return [];\r\n    try {\r\n        const countBN = await contract.ticketCount();\r\n        const count = Number(countBN);\r\n        if (count === 0) return [];\r\n\r\n        console.log(`Workspaceing ${count} issued ticket IDs...`);\r\n        const ids: number[] = [];\r\n        const promises: Promise<ethers.BigNumber>[] = [];\r\n        // Loop through indices of the issuedTickets array/getter\r\n        for (let i = 0; i < count; i++) {\r\n            // Assuming issuedTickets getter takes an index\r\n            promises.push(contract.issuedTickets(i));\r\n        }\r\n        const results = await Promise.all(promises);\r\n        results.forEach(tokenIdBN => {\r\n            ids.push(Number(tokenIdBN));\r\n        });\r\n        console.log(\"All issued ticket IDs:\", ids);\r\n        // Frontend will need to filter these based on ownership/refunded status if needed\r\n        return ids;\r\n\r\n    } catch (error) {\r\n        console.error(\"Error getting available/issued tickets:\", error);\r\n        toast.error(\"Could not retrieve list of issued tickets.\");\r\n        return [];\r\n    }\r\n};\r\n\r\n// --- getQRHash (Example - Requires adding to TicketNFT ABI) ---\r\nexport const getQRHash = async (tokenId: number): Promise<string | null> => {\r\n    const nftContract = await getTicketNFTContract(true);\r\n    if (!nftContract) return null;\r\n    try {\r\n        // --- Ensure getQRHash exists in TICKET_NFT_ABI ---\r\n        const qrHash = await nftContract.getQRHash(tokenId);\r\n        return qrHash;\r\n    } catch (error) {\r\n        console.error(`Error getting QR Hash for token ${tokenId}:`, error);\r\n        return null;\r\n    }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}