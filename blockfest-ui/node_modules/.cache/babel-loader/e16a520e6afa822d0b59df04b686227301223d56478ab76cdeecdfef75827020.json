{"ast":null,"code":"/**\r\n * Converts IPFS URI to HTTPS URL and fetches JSON metadata\r\n * This function handles both IPFS URIs and regular URLs, with improved logging and error handling\r\n */\nexport async function fetchMetadataFromUri(uri) {\n  if (!uri) {\n    console.warn(\"Missing URI\");\n    return null;\n  }\n  let gatewayUrl = uri;\n\n  // Convert IPFS URI to an HTTPS gateway URL if needed\n  if (uri.startsWith('ipfs://')) {\n    const cid = uri.substring(7); // Remove \"ipfs://\"\n    // Using ipfs.io as default gateway - replace with your preferred gateway if needed\n    gatewayUrl = `https://ipfs.io/ipfs/${cid}`;\n    console.log(\"Converting IPFS URI to:\", gatewayUrl);\n  }\n  try {\n    console.log(\"Fetching metadata from:\", gatewayUrl);\n    const response = await fetch(gatewayUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status} for ${gatewayUrl}`);\n    }\n    const metadata = await response.json();\n\n    // Also convert image URI within metadata if it's IPFS\n    if (metadata !== null && metadata !== void 0 && metadata.image) {\n      if (metadata.image.startsWith('ipfs://')) {\n        const imageCid = metadata.image.substring(7);\n        // Try multiple IPFS gateways in case one fails\n        const gateways = ['https://ipfs.io/ipfs/', 'https://gateway.pinata.cloud/ipfs/', 'https://cloudflare-ipfs.com/ipfs/'];\n\n        // Test which gateway responds fastest\n        const imageUrl = await Promise.any(gateways.map(async gateway => {\n          const url = `${gateway}${imageCid}`;\n          const response = await fetch(url, {\n            method: 'HEAD'\n          });\n          if (response.ok) {\n            return url;\n          }\n          throw new Error(`Gateway ${gateway} failed`);\n        })).catch(() => `https://ipfs.io/ipfs/${imageCid}`); // Fallback to default gateway\n\n        metadata.image = imageUrl;\n        console.log(\"Converting image IPFS URI to:\", metadata.image);\n      }\n\n      // Verify the image URL is accessible\n      try {\n        const imageResponse = await fetch(metadata.image, {\n          method: 'HEAD'\n        });\n        if (!imageResponse.ok) {\n          console.warn(`Image URL not accessible: ${metadata.image}`);\n          metadata.image = undefined;\n        }\n      } catch (error) {\n        console.warn(`Failed to verify image URL: ${metadata.image}`, error);\n        metadata.image = undefined;\n      }\n    }\n    return metadata;\n  } catch (error) {\n    console.error(`Failed to fetch or parse metadata from ${gatewayUrl}:`, error);\n    return null;\n  }\n}\nexport default fetchMetadataFromUri;","map":{"version":3,"names":["fetchMetadataFromUri","uri","console","warn","gatewayUrl","startsWith","cid","substring","log","response","fetch","ok","Error","status","metadata","json","image","imageCid","gateways","imageUrl","Promise","any","map","gateway","url","method","catch","imageResponse","undefined","error"],"sources":["C:/Users/negis/OneDrive/Desktop/new project/blockfest-ui/src/utils/metadata.ts"],"sourcesContent":["/**\r\n * Converts IPFS URI to HTTPS URL and fetches JSON metadata\r\n * This function handles both IPFS URIs and regular URLs, with improved logging and error handling\r\n */\r\nexport async function fetchMetadataFromUri(uri: string | null): Promise<any | null> {\r\n    if (!uri) {\r\n        console.warn(\"Missing URI\");\r\n        return null;\r\n    }\r\n    \r\n    let gatewayUrl = uri;\r\n    \r\n    // Convert IPFS URI to an HTTPS gateway URL if needed\r\n    if (uri.startsWith('ipfs://')) {\r\n        const cid = uri.substring(7); // Remove \"ipfs://\"\r\n        // Using ipfs.io as default gateway - replace with your preferred gateway if needed\r\n        gatewayUrl = `https://ipfs.io/ipfs/${cid}`;\r\n        console.log(\"Converting IPFS URI to:\", gatewayUrl);\r\n    }\r\n    \r\n    try {\r\n        console.log(\"Fetching metadata from:\", gatewayUrl);\r\n        const response = await fetch(gatewayUrl);\r\n        \r\n        if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status} for ${gatewayUrl}`);\r\n        }\r\n        \r\n        const metadata = await response.json();\r\n        \r\n        // Also convert image URI within metadata if it's IPFS\r\n        if (metadata?.image) {\r\n            if (metadata.image.startsWith('ipfs://')) {\r\n                const imageCid = metadata.image.substring(7);\r\n                // Try multiple IPFS gateways in case one fails\r\n                const gateways = [\r\n                    'https://ipfs.io/ipfs/',\r\n                    'https://gateway.pinata.cloud/ipfs/',\r\n                    'https://cloudflare-ipfs.com/ipfs/'\r\n                ];\r\n                \r\n                // Test which gateway responds fastest\r\n                const imageUrl = await Promise.any(\r\n                    gateways.map(async (gateway) => {\r\n                        const url = `${gateway}${imageCid}`;\r\n                        const response = await fetch(url, { method: 'HEAD' });\r\n                        if (response.ok) {\r\n                            return url;\r\n                        }\r\n                        throw new Error(`Gateway ${gateway} failed`);\r\n                    })\r\n                ).catch(() => `https://ipfs.io/ipfs/${imageCid}`); // Fallback to default gateway\r\n                \r\n                metadata.image = imageUrl;\r\n                console.log(\"Converting image IPFS URI to:\", metadata.image);\r\n            }\r\n            \r\n            // Verify the image URL is accessible\r\n            try {\r\n                const imageResponse = await fetch(metadata.image, { method: 'HEAD' });\r\n                if (!imageResponse.ok) {\r\n                    console.warn(`Image URL not accessible: ${metadata.image}`);\r\n                    metadata.image = undefined;\r\n                }\r\n            } catch (error) {\r\n                console.warn(`Failed to verify image URL: ${metadata.image}`, error);\r\n                metadata.image = undefined;\r\n            }\r\n        }\r\n        \r\n        return metadata;\r\n    } catch (error) {\r\n        console.error(`Failed to fetch or parse metadata from ${gatewayUrl}:`, error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport default fetchMetadataFromUri;"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,eAAeA,oBAAoBA,CAACC,GAAkB,EAAuB;EAChF,IAAI,CAACA,GAAG,EAAE;IACNC,OAAO,CAACC,IAAI,CAAC,aAAa,CAAC;IAC3B,OAAO,IAAI;EACf;EAEA,IAAIC,UAAU,GAAGH,GAAG;;EAEpB;EACA,IAAIA,GAAG,CAACI,UAAU,CAAC,SAAS,CAAC,EAAE;IAC3B,MAAMC,GAAG,GAAGL,GAAG,CAACM,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9B;IACAH,UAAU,GAAG,wBAAwBE,GAAG,EAAE;IAC1CJ,OAAO,CAACM,GAAG,CAAC,yBAAyB,EAAEJ,UAAU,CAAC;EACtD;EAEA,IAAI;IACAF,OAAO,CAACM,GAAG,CAAC,yBAAyB,EAAEJ,UAAU,CAAC;IAClD,MAAMK,QAAQ,GAAG,MAAMC,KAAK,CAACN,UAAU,CAAC;IAExC,IAAI,CAACK,QAAQ,CAACE,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,uBAAuBH,QAAQ,CAACI,MAAM,QAAQT,UAAU,EAAE,CAAC;IAC/E;IAEA,MAAMU,QAAQ,GAAG,MAAML,QAAQ,CAACM,IAAI,CAAC,CAAC;;IAEtC;IACA,IAAID,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAEE,KAAK,EAAE;MACjB,IAAIF,QAAQ,CAACE,KAAK,CAACX,UAAU,CAAC,SAAS,CAAC,EAAE;QACtC,MAAMY,QAAQ,GAAGH,QAAQ,CAACE,KAAK,CAACT,SAAS,CAAC,CAAC,CAAC;QAC5C;QACA,MAAMW,QAAQ,GAAG,CACb,uBAAuB,EACvB,oCAAoC,EACpC,mCAAmC,CACtC;;QAED;QACA,MAAMC,QAAQ,GAAG,MAAMC,OAAO,CAACC,GAAG,CAC9BH,QAAQ,CAACI,GAAG,CAAC,MAAOC,OAAO,IAAK;UAC5B,MAAMC,GAAG,GAAG,GAAGD,OAAO,GAAGN,QAAQ,EAAE;UACnC,MAAMR,QAAQ,GAAG,MAAMC,KAAK,CAACc,GAAG,EAAE;YAAEC,MAAM,EAAE;UAAO,CAAC,CAAC;UACrD,IAAIhB,QAAQ,CAACE,EAAE,EAAE;YACb,OAAOa,GAAG;UACd;UACA,MAAM,IAAIZ,KAAK,CAAC,WAAWW,OAAO,SAAS,CAAC;QAChD,CAAC,CACL,CAAC,CAACG,KAAK,CAAC,MAAM,wBAAwBT,QAAQ,EAAE,CAAC,CAAC,CAAC;;QAEnDH,QAAQ,CAACE,KAAK,GAAGG,QAAQ;QACzBjB,OAAO,CAACM,GAAG,CAAC,+BAA+B,EAAEM,QAAQ,CAACE,KAAK,CAAC;MAChE;;MAEA;MACA,IAAI;QACA,MAAMW,aAAa,GAAG,MAAMjB,KAAK,CAACI,QAAQ,CAACE,KAAK,EAAE;UAAES,MAAM,EAAE;QAAO,CAAC,CAAC;QACrE,IAAI,CAACE,aAAa,CAAChB,EAAE,EAAE;UACnBT,OAAO,CAACC,IAAI,CAAC,6BAA6BW,QAAQ,CAACE,KAAK,EAAE,CAAC;UAC3DF,QAAQ,CAACE,KAAK,GAAGY,SAAS;QAC9B;MACJ,CAAC,CAAC,OAAOC,KAAK,EAAE;QACZ3B,OAAO,CAACC,IAAI,CAAC,+BAA+BW,QAAQ,CAACE,KAAK,EAAE,EAAEa,KAAK,CAAC;QACpEf,QAAQ,CAACE,KAAK,GAAGY,SAAS;MAC9B;IACJ;IAEA,OAAOd,QAAQ;EACnB,CAAC,CAAC,OAAOe,KAAK,EAAE;IACZ3B,OAAO,CAAC2B,KAAK,CAAC,0CAA0CzB,UAAU,GAAG,EAAEyB,KAAK,CAAC;IAC7E,OAAO,IAAI;EACf;AACJ;AAEA,eAAe7B,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}